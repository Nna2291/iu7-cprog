#include <stdio.h>
#include <stdint.h>

#define ERR_OK 0
#define ERR_IO 1
#define ERR_RANGE 2
#define BIT_IN_BYTES 8

/*
 * @brief   Функция для вывода двоичного числа
 *
 * @param[in]   x   Число для вывода
 */
void print_bin(uint32_t x)
{
    for (int i = sizeof(x) * BIT_IN_BYTES - 1; i >= 0; i--)
    {
        printf("%u", (x >> i) & 1);
    }
}


/*
 * @brief   Циклический свдиг 32-битного числа на n позиций влево
 *
 * @param[in]   a   Число для сдвига
 * @param[in]   n   Число указывающее на сколько позиций необходимо сдвинуть число
 *
 * @return  Сдвинутое число a на n позиций влево
 */
uint32_t cyclic_shift(uint32_t a, int n)
{
    /*
     * Для наглядности введем число равное (UINT_MAX - 1)
     *
     * В двоичной форме оно будет представлено так: 11111111111111111111111111111110
     *
     * Сделаем побитовый сдвиг таким образом, что бы получить старший разряд и нули перед ним. Для этого необходимо
     * сделать побитовый сдвиг на 31 бит. То есть, (количество бит в числе - 1)
     *
     * Получим число: 00000000000000000000000000000001
     *
     * Теперь сделаем сдвиг исходного числа влево на 1, получим: 11111111111111111111111111111100
     *
     * Получили новое число с пустым младшим разрядом
     *
     * Выполним побитовое или, таким образом поставим старший разряд исходного числа вместо младшего.
     * Мы сдвинули число циклически на 1 позицию влево. При выполнении такой операции n раз, число сдвинется на n позиций
     * влево
     */
    for (int i = 0; i < n; i++)
    {
        a = (a << 1) | (a >> (sizeof(a) * BIT_IN_BYTES - 1));
    }
    return a;
}

int main(void)
{
    uint32_t a;
    int n;
    printf("Enter a and n: ");
    if (scanf("%u%d", &a, &n) != 2)
    {
        printf("Error: Input error!");
        return ERR_IO;
    }
    if (n < 0)
    {
        printf("Error: n must be more than zero");
        return ERR_RANGE;
    }
    printf("Result: ");
    a = cyclic_shift(a, n);
    print_bin(a);
}
